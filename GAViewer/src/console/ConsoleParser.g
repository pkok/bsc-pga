header "pre_include_hpp" {
#include "consolestatement.h"
}

header "pre_include_cpp" {
#include <iostream>
#include <antlr/String.hpp>
#include "../state.h"
#include "console.h"
#include "consolescope.h"
#include "consolestatement.h"
#include "consolevariable.h"
using namespace std;
}


header "post_include_cpp" {
consoleScope *g_currentParsingScope = NULL;
}

options {
	mangleLiteralPrefix = "TK_";
	language="Cpp";
	genHashLines=false;
}

class ConsoleParser extends Parser;
options {
	k = 3;
	importVocab=ConsoleLexer;	// use vocab generated by lexer
	buildAST=false;
}


input returns [consoleStmtListStmt *cs] {
	g_currentParsingScope = g_state->m_globalScope; // init scope
	consoleStmtListStmt *sl = NULL; cs = NULL;
	} 
	:
	sl=stmtlist {cs = sl; } EOF {
		while (g_currentParsingScope && (g_currentParsingScope != g_state->m_globalScope))
			g_currentParsingScope = g_currentParsingScope->deleteScope();

	}

	;

stmtlist returns [consoleStmtListStmt *cs]
	{cs = NULL;
	consoleStatement *s = NULL; } 
	:
	(s=stmt {
		if (s) {
			s->stmtListChild(1);
			if (cs) cs->addChild(s);
			else cs = new consoleStmtListStmt(s);
		}})*
	;

stmt returns [consoleStatement *cs] options {/*generateAmbigWarnings = false;*/}
	{int verbose = 0; consoleExprListStmt *el = NULL; consoleStmtListStmt *sl = NULL; cs = NULL; int m = -1; string name;}
	:
	// is this really required, or just suppress the ambig warnings?:
	{(LA(1) != SEMICOLON) && (LA(1) != CURLYOPEN) && (LA(1) != COMMA) && 
	(LA(1) != TK_return) && (LA(1) != TK_break) && (LA(1) != TK_continue) && 
	(LA(1) != TK_suspend) && (LA(1) != TK_dynamic)  && (LA(1) != TK_while) && 
	(LA(1) != TK_if)  && (LA(1) != TK_switch) && (LA(1) != TK_for) &&
	(LA(1) != TK_function)  && (LA(1) != TK_batch)}? cs=exprlist (COMMA {verbose =1; }| SEMICOLON) {if (cs) cs->verbose(verbose);} |
	t1:SEMICOLON {cs = new consoleDummyStmt(t1->getLine(), t1->getColumn());} |
	t2:COMMA {cs = new consoleDummyStmt(t2->getLine(), t2->getColumn());} |
	CURLYOPEN cs=stmtlist CURLYCLOSE {} | // maybe put this in sub class, so we can reproduce curlies
	t3:TK_return el=exprlist SEMICOLON {cs = new consoleReturnStmt(t3->getLine(), t3->getColumn(), el); } |
	t4:TK_break SEMICOLON {cs = new consoleBreakStmt(t4->getLine(), t4->getColumn(), 0);} |
	t5:TK_continue SEMICOLON {cs = new consoleBreakStmt(t5->getLine(), t5->getColumn(), 1);} |
	t6:TK_suspend SEMICOLON {cs = new consoleBreakStmt(t6->getLine(), t6->getColumn(), 2);} |
	t7:TK_dynamic CURLYOPEN (t13:IDENTIFIER COLON)? sl=stmtlist CURLYCLOSE {if (sl) cs = new consoleDynStmt(t7->getLine(), t7->getColumn(), sl, (t13) ? t13->getText() : "");} |
	t8:TK_inner_product PAROPEN t9:FUNCNAME PARCLOSE {cs = new consoleSetStmt(t8->getLine(), t8->getColumn(), t8->getText(), t9->getText());} |
	t10:TK_default_model PAROPEN m = model PARCLOSE {cs = new consoleSetStmt(t10->getLine(), t10->getColumn(), t10->getText(), m);} |
	t11:TK_default_model PAROPEN PARCLOSE {cs = new consoleSetStmt(t11->getLine(), t11->getColumn(), t11->getText(), -1);} |
	t12:TK_variable name=funcDefName SEMICOLON {g_currentParsingScope->setVariable(name); cs = new consoleDummyStmt(t12->getLine(), t12->getColumn());} |
	cs=while_ {} |
	cs=for_ {} |
	cs=if_ {} |
	cs=switch_ {} |
	cs=function {}
	;

while_ returns [consoleWhileStmt *ws] 
	{ws = NULL; consoleExprListStmt *el = NULL; consoleStatement *s = NULL;}
	:
	t1:TK_while PAROPEN el=exprlist PARCLOSE s=stmt 
	{ws = new consoleWhileStmt(t1->getLine(), t1->getColumn(), el, s);}
	;

for_ returns [consoleForStmt *fs] 
	{fs = NULL; consoleExprListStmt *e1 = NULL, *e2 = NULL, *e3 = NULL; consoleStatement *s = NULL;}
	:
	t1:TK_for PAROPEN e1=exprlist SEMICOLON e2=exprlist SEMICOLON e3=exprlist PARCLOSE s=stmt {
		fs = new consoleForStmt(t1->getLine(), t1->getColumn(), e1, e2, e3, s);
	}
	;

if_ returns [consoleIfElseStmt *ifs] 
	{ifs = NULL; consoleExprListStmt *e = NULL; consoleStatement *is = NULL, *es = NULL;}
	:
	 t1:TK_if PAROPEN e=exprlist PARCLOSE is=stmt ( TK_else es=stmt )?  {
		ifs = new consoleIfElseStmt(t1->getLine(), t1->getColumn(), e, is, es);
	} 
	;

switch_ returns [consoleSwitchStmt *ss]
	{ss = NULL; consoleExprListStmt *e = NULL; consoleCaseListStmt *cl = NULL;}
	:
	t1:TK_switch PAROPEN e=exprlist PARCLOSE CURLYOPEN cl=caselist CURLYCLOSE {
		ss = new consoleSwitchStmt(t1->getLine(), t1->getColumn(), e, cl);
	}
	;

caselist returns [consoleCaseListStmt *ccl]
	{consoleCaseStmt *cs = NULL; ccl = NULL;}
	:
	(cs=case_ {
		if (ccl && cs) ccl->addChild(cs);
		else if (cs) ccl = new consoleCaseListStmt(cs->line(), cs->column(), cs);})*
	;


case_ returns [consoleCaseStmt *cs] 
	{cs = NULL; consoleExprListStmt *el = NULL; consoleStmtListStmt *sl = NULL;}
	:
	{(LA(4) != CURLYCLOSE) && (LA(4) != TK_case) && (LA(4) != TK_default)}?  t1:TK_case el=exprlist COLON sl=stmtlist {
		cs = new consoleCaseStmt(t1->getLine(), t1->getColumn(), el, sl);
	}
	|
	t2:TK_case el=exprlist COLON {
		cs = new consoleCaseStmt(t2->getLine(), t2->getColumn(), el, NULL);
	}
	|
	{(LA(4) != CURLYCLOSE) && (LA(4) != TK_case) && (LA(4) != TK_default)}?  t3:TK_default COLON sl=stmtlist {
		cs = new consoleCaseStmt(t3->getLine(), t3->getColumn(), NULL, sl);
	}
	|
	t4:TK_default COLON {
		cs = new consoleCaseStmt(t4->getLine(), t4->getColumn(), NULL, NULL);
	}
	;

exprlist returns [consoleExprListStmt *el] 
	{el = NULL; consoleStatement *e;}
	: 
	(e=expr {
		if (el && e) el->addChild(e);
		else if (e) el = new consoleExprListStmt(e);})*
	;

expr returns [consoleStatement *cs] 
	{cs = NULL; consoleArrayIdxListStmt *ail = NULL; consoleFuncArgListStmt *fal = NULL; consoleExprListStmt *el = NULL; consoleStatement *e = NULL; int m = -1;}
	: 
	t1:CONSTANT {cs = new consoleConstantScalarStmt(t1->getLine(), t1->getColumn(), atof(t1->getText().c_str()));} |

	{ail = NULL;} t5:IDENTIFIER ({LA(1) == SQUAREOPEN}? ail=arrayidxlist |) {cs = new consoleVariableStmt(t5->getLine(), t5->getColumn(), t5->getText().c_str(), 0, ail);} |
	{ail = NULL;} t6:GLOBAL t7:IDENTIFIER ({LA(1) == SQUAREOPEN}? ail=arrayidxlist |) {cs = new consoleVariableStmt(t6->getLine(), t6->getColumn(), t7->getText().c_str(), 1, ail);} |

	o:OPERATOR e=expr {if (e) {e->setOp(NULL, o->getLine(), o->getColumn(), o->getText().c_str()); cs = e;}} | // todo: get filename from scope??? or use getFilename()?
	t9:PAROPEN el=exprlist PARCLOSE {if (el) {cs = new consoleParExprStmt(t9->getLine(), t9->getColumn(), el);}} | 
	{fal = NULL;} fn3:FUNCNAME PAROPEN ({LA(1) != PARCLOSE}? fal=funcarglist PARCLOSE | PARCLOSE) {cs = new consoleFuncCallStmt(fn3->getLine(), fn3->getColumn(), fn3->getText().c_str(), fal, 0); } |
	{fal = NULL;} t8:GLOBAL fn2:FUNCNAME PAROPEN ({LA(1) != PARCLOSE}? fal=funcarglist PARCLOSE | PARCLOSE) {cs = new consoleFuncCallStmt(t8->getLine(), t8->getColumn(), fn2->getText().c_str(), fal, 1); } |
	{e = NULL; } t10:PAROPEN m = model PARCLOSE e = expr {
		if (e) cs = new consoleFuncCallStmt(t10->getLine(), t10->getColumn(), 
		(m == MVI_E3GA) ? "cast_e3ga" : ((m == MVI_P3GA) ? "cast_p3ga" : ((m == MVI_C3GA) ? "cast_c3ga" : ((m == MVI_C5GA) ? "cast_c5ga" : "cast_i2ga"))),
		new consoleFuncArgListStmt(new consoleExprListStmt(e)), 1); 
	}
	;

funcarglist returns [consoleFuncArgListStmt *fal]
	{consoleExprListStmt *el = NULL; fal = NULL;}
	:
	el=exprlist {if (el) fal = new consoleFuncArgListStmt(el); el = NULL;}
	(COMMA el=exprlist  {if (el) {if (fal) fal->addChild(el); else fal = new consoleFuncArgListStmt(el);} el=NULL;})*
	;

arrayidxlist returns [consoleArrayIdxListStmt *ail]
	{consoleExprListStmt *el = NULL; ail = NULL;}
	:
	(t1:SQUAREOPEN el=exprlist t2:SQUARECLOSE {
		if (ail && el) ail->addChild(el);
		else if(el) ail = new consoleArrayIdxListStmt(t1->getLine(), t1->getColumn(), el);})*
	;

funcDefName returns [string s]
	{s = "";}
	:
	t1:IDENTIFIER {s = t1->getText();} |
	t2:FUNCNAME {s = t2->getText();}
	;

function returns [consoleStatement *fs]
	{fs = NULL; consoleFuncArgSpecListStmt *fasl = NULL; consoleStmtListStmt *sl = NULL; int f = 1; string name; int i; consoleFuncArgSpecStmt *fas = NULL; bool def = false;}
	:
	(t1:TK_function {f = 1;} | t2:TK_batch {f = 0;}) name=funcDefName  // FUNCTION 'name'
	PAROPEN ({LA(1) != PARCLOSE}? fasl=funcargspeclist)? PARCLOSE  // ( arg1, arg2, ... ) 
		{
			g_currentParsingScope->setFunction(name); 
			g_currentParsingScope = new consoleScope(name.c_str(), g_currentParsingScope);
			i = 0; // add all names as variables
			while (fasl && (fas = fasl->argSpec(i++)))
				g_currentParsingScope->setVariable(fas->name());
		} // add function to scope, set variables, enter new scope
	(CURLYOPEN sl=stmtlist {def = true;} CURLYCLOSE | SEMICOLON) { // { stmt1, stmt2, ... } or ;
		if (def) { // function definition
			fs = new consoleFuncStmt(((f) ? t1 : t2)->getLine(), ((f) ? t1 : t2)->getColumn(), name.c_str(), fasl, sl, f); 
		}
		else { // function declaration
			fs = new consoleFuncDeclStmt(((f) ? t1 : t2)->getLine(), ((f) ? t1 : t2)->getColumn(), name.c_str(), fasl, f);
		}
		g_currentParsingScope = g_currentParsingScope->deleteScope();
	}
	;

funcargspeclist returns [consoleFuncArgSpecListStmt *fasl]
	{fasl = NULL; consoleFuncArgSpecStmt *fas = NULL;}
	:
	fas=argspec {if (fas) fasl = new consoleFuncArgSpecListStmt(fas->line(), fas->column(), fas); fas = NULL;}
	(COMMA fas=argspec  {
		if (fasl && fas) fasl->addChild(fas);
		else if (fas) fasl = new consoleFuncArgSpecListStmt(fas->line(), fas->column(), fas);
		fas = NULL;
		})*
	;

argspec returns [consoleFuncArgSpecStmt *fas] 
	{fas = NULL; string name;}
	:
	
	name=funcDefName {fas = new consoleFuncArgSpecStmt(0, 0, name.c_str(), CVF_ANY_MODEL);} | // todo: set line and column correctly
	t2:TK_e3ga name=funcDefName {fas = new consoleFuncArgSpecStmt(t2->getLine(), t2->getColumn(), name.c_str(), MVI_E3GA);} |
	t4:TK_p3ga name=funcDefName {fas = new consoleFuncArgSpecStmt(t4->getLine(), t4->getColumn(), name.c_str(), MVI_P3GA);} |
	t6:TK_c3ga name=funcDefName {fas = new consoleFuncArgSpecStmt(t6->getLine(), t6->getColumn(), name.c_str(), MVI_C3GA);} |
	t8:TK_c5ga name=funcDefName {fas = new consoleFuncArgSpecStmt(t6->getLine(), t8->getColumn(), name.c_str(), MVI_C5GA);} |
	t10:TK_i2ga name=funcDefName {fas = new consoleFuncArgSpecStmt(t10->getLine(), t10->getColumn(), name.c_str(), MVI_I2GA);}
	;


model returns [int m] 
	{m = -1;}
	:
	TK_e3ga {return MVI_E3GA;} |
	TK_p3ga {return MVI_P3GA;} |
	TK_c3ga {return MVI_C3GA;} |
	TK_c5ga {return MVI_C5GA;} |
	TK_i2ga {return MVI_I2GA;}
;



